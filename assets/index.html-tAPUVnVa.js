import{_ as s,c as n,a,o as i}from"./app-CNZkbZ7y.js";const t={};function l(c,e){return i(),n("div",null,e[0]||(e[0]=[a(`<div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>public &lt;T&gt; T tryLock(String key, Supplier&lt;T&gt; call) {</span></span>
<span class="line"><span>    // 获取锁</span></span>
<span class="line"><span>    RLock lock = redissonClient.getLock(key);</span></span>
<span class="line"><span>    // 未获取到直接返回</span></span>
<span class="line"><span>    if (!lock.tryLock()) {</span></span>
<span class="line"><span>        log.info(&quot;RedisLocker.tryLock failed {}&quot;, key);</span></span>
<span class="line"><span>        throw Exceptions.lock();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    // 执行</span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>        return call.get();</span></span>
<span class="line"><span>    } finally {</span></span>
<span class="line"><span>        lock.unlock();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong><code>public &lt;T&gt;</code></strong>：表示该方法是一个公共的泛型方法，<code>T</code> 是类型参数，意味着调用者可以指定任何类型作为 <code>T</code>。</li><li><strong><code>T tryLock(...)</code></strong>：表示该方法将返回类型为 <code>T</code> 的结果。这里的 <code>T</code> 就是你在调用方法时指定的具体类型。</li><li><strong><code>Supplier&lt;T&gt; call</code></strong>：<code>call</code> 参数是一个 <code>Supplier&lt;T&gt;</code> 类型的对象，它是一个函数式接口，代表了一个不接受任何参数但返回 <code>T</code> 类型结果的操作。</li></ul><h4 id="返回-string-类型" tabindex="-1"><a class="header-anchor" href="#返回-string-类型"><span>返回 <code>String</code> 类型</span></a></h4><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>String result = locker.tryLock(&quot;stringLock&quot;, () -&gt; &quot;Hello, World!&quot;);</span></span>
<span class="line"><span>System.out.println(result);  // 输出: Hello, World!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>T</code> 被推断为 <code>String</code> 类型，因为 Lambda 表达式 <code>() -&gt; &quot;Hello, World!&quot;</code> 返回的是一个 <code>String</code>。</p><h4 id="返回-integer-类型" tabindex="-1"><a class="header-anchor" href="#返回-integer-类型"><span>返回 <code>Integer</code> 类型</span></a></h4><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>Integer result = locker.tryLock(&quot;integerLock&quot;, () -&gt; 42);</span></span>
<span class="line"><span>System.out.println(result);  // 输出: 42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里，<code>T</code> 被推断为 <code>Integer</code> 类型，因为 Lambda 表达式 <code>() -&gt; 42</code> 返回的是一个 <code>Integer</code>。</p><h3 id="显式指定类型参数" tabindex="-1"><a class="header-anchor" href="#显式指定类型参数"><span>显式指定类型参数</span></a></h3><p>虽然大多数情况下 Java 编译器可以根据上下文自动推断出类型参数 <code>T</code>，但在某些复杂的情况下，你可能需要显式地指定类型参数。例如：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>String result = locker.&lt;String&gt;tryLock(&quot;stringLock&quot;, () -&gt; &quot;Hello, World!&quot;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>显式指定类型参数通常是不必要的，编译器可以自动推断出来。</p><h3 id="缺少泛型声明的问题" tabindex="-1"><a class="header-anchor" href="#缺少泛型声明的问题"><span>缺少泛型声明的问题</span></a></h3><p>当你写成 <code>public T tryLock(String key, Supplier&lt;T&gt; call)</code> 时，Java 编译器并不知道 <code>T</code> 是什么，因为它没有看到任何关于 <code>T</code> 的定义或声明。这会导致编译错误，因为 <code>T</code> 被视为未定义的类型。</p><p>为了使方法能够接受和返回任意类型的数据，你需要在方法签名中显式地声明泛型类型参数 <code>&lt;T&gt;</code>。正确的写法应该是：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>public &lt;T&gt; T tryLock(String key, Supplier&lt;T&gt; call) {</span></span>
<span class="line"><span>    // 方法体</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里 <code>&lt;T&gt;</code> 告诉编译器这是一个泛型方法，并且 <code>T</code> 是一个可以在整个方法签名和方法体内使用的类型参数。这样，编译器就知道 <code>T</code> 是一个待定的类型，在调用方法时由调用者指定或者由编译器根据上下文推断。</p>`,17)]))}const o=s(t,[["render",l],["__file","index.html.vue"]]),r=JSON.parse('{"path":"/article/tc8c8t6j/","title":"方法泛型返回值","lang":"zh-CN","frontmatter":{"title":"方法泛型返回值","createTime":"2025/03/19 17:43:04","permalink":"/article/tc8c8t6j/"},"headers":[],"readingTime":{"minutes":1.97,"words":592},"git":{"updatedTime":1748077734000,"contributors":[{"name":"netjic","username":"netjic","email":"netjic@163.com","commits":1,"avatar":"https://gravatar.com/avatar/374578fe375437866193fe849b770e3f9c74eacc1a7125303870c05b7a97309d?d=retro"}]},"filePathRelative":"代码解释/方法泛型返回值.md","categoryList":[{"id":"f8a028","sort":10013,"name":"代码解释"}],"bulletin":false}');export{o as comp,r as data};
