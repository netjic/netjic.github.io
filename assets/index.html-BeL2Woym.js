import{_ as t,c as a,a as r,o as s}from"./app-DRG5qZNX.js";const n={};function o(i,e){return s(),a("div",null,e[0]||(e[0]=[r('<h2 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透"><span>缓存穿透</span></a></h2><blockquote><p>查询一个缓存中不存在的key，由于缓存未命中，逻辑判断是去查询数据库，但是数据库也无次记录，此时也就无法将新数据写到redis中，这将导致每次请求这个不存在的key时，后端服务都要去存储层去查询，一方面是增大了数据库压力，另一方面每次都要去数据库查询，也失去了缓存的意义</p></blockquote><p><strong>风险</strong></p><p>如果恶意攻击者利用不存在的数据进行频繁攻击，数据库的瞬时压力会增大，可能会导致系统崩掉</p><p><strong>解决方案</strong></p><p>可以在处理缓存时，将不存在的key的value值设为null写入缓存，并设置一个短暂过期时间</p><h2 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩"><span>缓存雪崩</span></a></h2><blockquote><p>批量key同一时间过期，导致缓存在某一时刻同时失效，请求全部转发到DB，数据库瞬时压力增大</p></blockquote><p><strong>风险</strong></p><p>数据库的瞬时压力会增大，可能会导致系统崩掉</p><p><strong>解决方案</strong></p><p>可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件</p><h2 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿"><span>缓存击穿</span></a></h2><blockquote><p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存</p></blockquote><p><strong>风险</strong></p><p>大并发的请求可能会瞬间把后端DB压垮</p><p><strong>解决方案</strong> 加锁，在线程1先发来请求，并且获取到了互斥锁。这时线程1就可以去查询数据库，接着将查询到的数据缓存到redis中，别的线程可以直接从redis中获取，最后记得释放锁，不然以后别的线程无法访问数据库。</p><p><strong>备注：</strong> 对于缓存击穿和缓存雪崩来说，区别就是缓存击穿针对的一个key，缓存雪崩针对的是批量key</p>',18)]))}const c=t(n,[["render",o],["__file","index.html.vue"]]),l=JSON.parse('{"path":"/article/iee72i39/","title":"缓存穿透，缓存击穿，缓存雪崩","lang":"zh-CN","frontmatter":{"title":"缓存穿透，缓存击穿，缓存雪崩","createTime":"2023/11/27 15:34:06","tags":["redis"],"permalink":"/article/iee72i39/"},"headers":[],"readingTime":{"minutes":1.93,"words":580},"git":{"updatedTime":1735723707000,"contributors":[{"name":"netjic","username":"netjic","email":"netjic@163.com","commits":1,"avatar":"https://gravatar.com/avatar/374578fe375437866193fe849b770e3f9c74eacc1a7125303870c05b7a97309d?d=retro"}]},"filePathRelative":"redis/缓存穿透，缓存击穿，缓存雪崩.md","categoryList":[{"id":"86a1b9","sort":10009,"name":"redis"}],"bulletin":false}');export{c as comp,l as data};
